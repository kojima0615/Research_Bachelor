import numpy as np
from joblib import Parallel, delayed
import matplotlib.pyplot as plt
import scipy
from numba import jit, prange,njit
hw = np.array([bin(i).count('1') for i in range(256)])
inv = np.load('./csv_data/inv_LUT.npy')
s_box = np.array([
        0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,
        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,
        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,
        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,
        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,
        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,
        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,
        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,
        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,
        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,
        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,
        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,
        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,
        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,
        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,
        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16,
        ])

inv_s_box = np.array((
        0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38, 0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB,
        0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87, 0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB,
        0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D, 0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E,
        0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2, 0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25,
        0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92,
        0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA, 0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84,
        0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A, 0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06,
        0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02, 0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B,
        0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA, 0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73,
        0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85, 0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E,
        0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89, 0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B,
        0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20, 0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4,
        0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31, 0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F,
        0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D, 0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF,
        0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0, 0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61,
        0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26, 0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D,
    ))

wave_size = 4690
#wave_size = 1600
data_size = 500000
X_MEMMAP_PATH = './memmap/AES_TI_wave_mask_v8_test_0-500000_all_square_memmap.npy'
#X_MEMMAP_PATH = './memmap/AES_TI_wave_unmask_v6_test_0-10000_memmap.npy'
x_memmap = np.memmap(
filename=X_MEMMAP_PATH, dtype=np.float, mode='r', shape=(data_size, wave_size, 1))
wave = x_memmap[:]
data_size = 400000
def calc_corr(w, hs):
    return np.corrcoef([w, hs])[0][1]

def calc_corr_cpa(w, hs):
    return np.array([np.corrcoef([w, hs[key]])[0][1] for key in range(256)])

def calc_corr_cpa_memmap(i, hs):
    w = wave[:,i]
    w = w.reshape(wave.shape[0])
    return np.array([np.corrcoef([w, hs[key]])[0][1] for key in range(256)])

def mutual_information(X, Y, bins=[1000,9]):
    # 同時確率分布p(x,y)の計算
    p_xy, xedges, yedges = np.histogram2d(X, Y, bins=bins, density=True)

    # p(x)p(y)の計算
    p_x, _ = np.histogram(X, bins=xedges, density=True)
    p_y, _ = np.histogram(Y, bins=yedges, density=True)
    p_x_y = p_x[:, np.newaxis] * p_y

    # dx と dy
    dx = xedges[1] - xedges[0]
    dy = yedges[1] - yedges[0]
    # 積分の要素
    elem = p_xy * np.ma.log(p_xy / p_x_y)
    # 相互情報量とp(x, y), p(x)p(y)を出力
    return np.sum(elem * dx * dy)

def calc_mi_memmap(i, hs):
    w = wave[:,i]
    w = w.reshape(wave.shape[0])
    return np.array([mutual_information(w, hs[key]) for key in range(256)])

def mk_labels(key1, p1, r5):
    out = p1 ^ key1
    out = inv[out]
    out = out ^ r5
    return hw[out]


@jit('i4[:,:](i4[:],i4[:])', nopython=True, parallel = True)
def mk_labels_twov(p1, p5):
    out = np.zeros((256 * 256, data_size), dtype= np.int32)
    for key1 in prange(256):
        for key5 in range(256):
            out[key1 * 256 + key5] = hw[inv[p1 ^ key1] ^ inv[p5 ^ key5]]
    return out


def calc_corr_time(w, hs, i):
    return np.array([np.corrcoef([w[:i+1], hs[key,:i+1]])[0][1] for key in range(256)])


#@jit('f4[:,:](f4[:], f4[:,:])',nopython=True, parallel = True)
def calc_corr_time_twov(w, hs, i):
    return np.array([np.corrcoef([w[:i+1], hs[key,:i+1]])[0][1] for key in range(256 * 256)],dtype = np.float32)

@jit('f4[:,:](f4[:],f4[:,:],i4)', nopython=True)
def calc_sc(w, hs, key_true):
    out = np.zeros((150000//100, 256) ,dtype = np.float32)
    for i in range(out.shape[0]):
        out[i] = [abs(abs(np.corrcoef(w[:(i+1)*100], hs[key,:(i+1)*100])[0,1])) for key in range(256)]
    return out

def calc_sc_wrap(w, hs, key_true):
    indices = np.arange(hs.shape[1])
    indices = np.random.permutation(indices)
    indices = indices[:160000]
    wt = w[indices]
    hst = hs[:, indices] 
    out = calc_sc(wt, hst, key_true)
    out = 255 - np.argsort(np.argsort(out))[:,key_true].ravel()
    del wt, hst, indices
    return out

@jit('i4[:](f4[:,:],i4)', nopython=True, parallel = True)
def parallel_argsort(preds, key_true):
    out = np.zeros(preds.shape[0], dtype=np.int32)
    for i in prange(preds.shape[0]):
            out[i] = 65280 + 255 - np.argsort(np.argsort(preds[i]))[key_true]
    return out

@jit('f4[:](f4[:],f4[:,:],i4)', nopython=True, parallel = True)
def calc_sc_twov(w, hs, key_true):
    out = np.zeros((300000//10000, 256 * 256) ,dtype = np.float32)
    indices = np.arange(hs.shape[1])
    indices = np.random.permutation(indices)
    indices = indices[:310000]
    wt = w[indices]
    hst = hs[:, indices]
    for key1 in range(256 * 4):
        for key2 in prange(64):
            key = key1 * 64 + key2
            for i in range(out.shape[0]):
                j = (i+1) * 10000
                out[i][key] = abs(np.corrcoef(wt[:j], hst[key,:j])[0,1])
    #del wt, hst
    #del indices
    print(0)
    return parallel_argsort(out, key_true).astype(np.float32)


def main():

    r = np.load('./csv_data/round1_inv_5byte_test_isomap_4000000_v3.npy')[:data_size]

    plaintext = np.load('./csv_data/round1_plain_1byte_test_isomap_4000000_v3.npy')[:data_size]
    key_true = np.load('./csv_data/round1_key_1byte_test_isomap_4000000_v3.npy')[0]

    plaintext5 = np.load('./csv_data/round1_plain_5byte_test_isomap_4000000_v3.npy')[:data_size]
    key5_true = np.load('./csv_data/round1_key_5byte_test_isomap_4000000_v3.npy')[0]
    #key_true = (key_true << 8) + key5_true
    key_true = np.int32(key_true)
    print(key_true)
    plaintext = plaintext.astype(np.int32)
    plaintext5 = plaintext5.astype(np.int32)
    
    #1byte仮定
    hs = np.array(Parallel(n_jobs=64, verbose=5)([delayed(mk_labels)(key, plaintext,\
    r) for key in range(256)]), dtype = np.float32)
    '''
    #2byte予測    
    hs = np.array(mk_labels_twov(plaintext, plaintext5), dtype = np.float32)
    print(hs.shape)
    '''
    #time
    
    #corr_out = np.array(Parallel(n_jobs=32, verbose=5)([delayed(calc_corr_cpa)(w, hs) for w in wave.T]))
    #corr_out = np.array(Parallel(n_jobs=32, verbose=5)([delayed(calc_corr_cpa_memmap)(i, hs) for i in range(wave.shape[1])]))
    #corr_out = np.array(Parallel(n_jobs=32, verbose=5)([delayed(calc_mi_memmap)(i, hs) for i in range(wave.shape[1])]))
    
    
    
    #number
    #779 v6
    #1687 v8
    w = wave[:data_size,1687]
    print(w.shape)
    w = w.reshape(data_size).astype(np.float32)
    
    '''
    corr_out = np.array(Parallel(n_jobs=32, verbose=5)([delayed(calc_corr_time_twov)(w, hs, i) for i in range(data_size-1)]))
    print(corr_out.shape)
    #np.save('./csv_data/corr_0214_unmask_TI_time', corr_out)
    corr_out = corr_out.T
    plt.figure(figsize = (15,10))
    for i in range(256):
        plt.plot(corr_out[i],color='grey')
    plt.plot(corr_out[key_true],color='red')
    
    plt.show()
    #plt.savefig("./image/corr_0214_unmask_TI_time.png")
    '''

    #success rate
    ave = 100
    #outs = np.zeros((ave, 300000//100),dtype=np.int64)
    outs = np.array(Parallel(n_jobs=64,  verbose=5)([delayed(calc_sc_wrap)(w, hs, key_true) for _ in range(ave)]))
    '''
    for i in range(ave):
        outs[i] = calc_sc_twov(w, hs, key_true)
    '''
    del hs
    sc = np.zeros(150000//100)
    np.save('./csv_data/cpa_0218_mask_TI_time_SC_v8_onevalue', outs)
    for i in range(ave):
        sc += (outs[i]==0)
        print(i)
    sc /= ave
    plt.plot(sc)
    plt.savefig("./image/cpa_0218_mask_TI_time_SC_v8_onevalue.png")
    
if __name__ == '__main__':
    main()